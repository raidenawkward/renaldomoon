More Joel on Software
===================

*(此文档中包含但不仅限于这本书的读后感, 也包括我个人发现的问题及理解 --tome.huang)*


[toc]


#[关于Joel文章的网站](http://www.joelonsoftware.com/)

#乔尔测试
---------


##乔尔测试内容包括

> 1. 你们使用版本控制系统吗?
> 2. 有一键部署吗?
> 3. 有每日构建吗?
> 4. 有Bug数据库吗?
> 5. 你们是否在写新代码前保证Bug都修复完了? ([无限缺陷方法论](#无限缺陷方法论))
> 6. 你们的进度表是最新的吗? ([我需要进一步读这个](#无痛软件时间表))
> 7. 有需求文档吗?
> 8. 程序员们有安静的工作环境吗?
> 9. 你们使用能买到的最好的工具吗?
> 10. 有测试团队吗?
> 11. 应聘者在面试时写代码吗?
> 12. 你们进行目标用户随机可用性测试吗([走廊可用性测试](#走廊可用性测试))?

[**我们是如何做的**](#我们是如何做的)


##无限缺陷方法论
>在Bug被修正之前等待的时间越长，以后要修正时的代价越大


##[无痛软件时间表](http://www.joelonsoftware.com/articles/fog0000000245.html)
(Painless Software Schedules)

##走廊可用性测试
在走廊随便拉一个人使用写好的程序, 重复进行可暴露大量问题


##我们是如何做的
1. 你们使用版本控制系统吗?
使用perforce, git做为版本管理工具

2. 有一键部署吗?
使用PBS, RBS平台, gradle, shell脚本控制版本同步, 编译和打包

3. 有每日构建吗?
不同项目构建周期不同, spay项目为一周两次

4. 有Bug数据库吗?
PLM系统, JIRA系统

5. 你们是否在写新代码前保证Bug都修复完了?
- bug修改与新工能开发同时进行.
- bug修改由QA及VOC驱动
- QA包括自测, SEL, CMT

6. 你们的进度表是最新的吗?
开发计划由developer给出建议, 由PM与BD协调后制定

7. 有需求文档吗?
需求文档，UX及GUI设计文档由PM提供

8. 程序员们有安静的工作环境吗?
没有, 会被不同的业务打断

9. 你们使用能买到的最好的工具吗?
是的, 性能足够的PC，多显示器, 市场版本开发样机, 正版软件

10. 有测试团队吗?
- spay项目组一般分配2-3名SEL测试人员做专题测试
- 项目release会分配2-3名SEL测试人员做版本测试
- 平均每developer配有0.13名测试人员

11. 应聘者在面试时写代码吗?
不写
参考: [The Guerrilla Guide to Interviewing <<面试简易指南>>](http://www.joelonsoftware.com/articles/fog0000000073.html)

12. 你们进行目标用户随机可用性测试吗?
spay项目是这样


##[这篇文章的原地址](http://www.joelonsoftware.com/articles/fog0000000043.html)




#语言选择和代码优化
-------------------

##施勒梅尔算法
~~Schlaemmer?~~

```c++
void strcat(char* dest, char* src) {
   while (*dest) dest++;
   while (*dest++ = *src++)
}
```

每次都是重头开始
**代码的效率**


##有关字符串的问题

###Pascal字符串
>- 字符串长度在255以内
>- 第一个字节存储字符串长度

e.g.
```c++
char* str = "\006hello!";
```


###String, StringBuffer和StringBuilder
1. String 内容不可变. 每次变更是生成了新的String. 大量String直接操作后会产生多个无用引用而
引起jvm开始gc, 速度会变慢.
2. StringBuffer**线程安全**, 维护缓冲区, 支持insert, append等操作, 对内容进行修改但不产生新对象.
3. StringBuilder**线程不安全**, 提供与StringBuffer兼容的API, 但不保证同步. 单个线程中比StringBuffer快




# 软件功能规格说明书
-------------------

## 它能带来的好处是
1. 编写代码的依据
- 功能定义先于编码, 能更加清晰地划分模块, 定义接口
- 更加清晰地讨论并形成解决方案

2. 减少沟通时间
 产品设计, 开发者, 测试人员及, 维护人员和客户都可能是读者

3. 制定开发进度的依据
 进度表对于开发过程同样重要

4. *细节问题会更早地暴露出来*


##功能规格说明书说应该包括

- 是功能说明书而不是技术说明书
- 从使用者的角度完整描述产品行为
- 设计产品最重要的是完成对用户体验的设计

*我目前对实现过程的理解:*
> 有哪些界面 -> 各界面功能 -> 界面间的跳转 -> work flow -> data flow -> 数据定义 -> 接口定义 -> 实现

应包含的内容:

0. 免责声明
    保护自己

1. 作者

2. 概述
    2.1. 文档的阅读人群
    2.2. 文档涉及的范围
    2.3. 文档不包含的内容

3. 使用场景
    构想真实生活中有**代表性**的人物的**逼真的**使用场景

    *可以包含:*
>    -他是谁
>    -他的职位/身份
>    -与产品有关场景的描述
>    -他如何使用产品
>    -产品如何帮他解决了问题
>    -解决问题后他变成了什么样子

4. 非目标
    4.1. 当前文档不做什么
    4.2. 当前文档设计中尚不支持的功能列表

5. 完整/全部业务流程图

6. *每个界面的规格说明*
    6.1. 为每个界面制定标准化命名
    6.2. *小节号可以代表界面间的关系*
    6.3. 界面中详细的功能和细节
    6.4. 界面中特别需要注意的内容
    6.5. **当前待解决的问题**
        6.5.1. 问题描述
        6.5.2. 当前进展
        6.5.3. 下一步需要做什么
    6.6. 必要的图表
    6.7. 必要的技术注解
    6.8. 显示说明对其它界面的跳转条件
    6.9. 界面的限制条件(用户输入限制, 软件/库/版本依赖, ..)

7. 不同角度的阅读者的注解

8. *修改记录*
spay项目和公司其它项目一般包含这个


##功能规格说明书说应及时更新

##这个文档应该由谁来编写?
**项目经理**
- 负责需求收集和软件功能设计, 然后编写此文档
- 协调与其它部门人员的合作(营销,文档,测试,本地化,其它)
- 了解公司的宏观战略

程序员
- 用代码实现以规格说明书的形式定义的功能

##项目经理的人选
1. 开发人员一般不适合做项目经理
开发人员的普遍弱项
- 文笔
- 市场嗅觉
- **用户视角**
- 界面设计

2. 营销人员一般不适合做项目经理
- 一般不具备技术素养

##项目经理与程序员的关系
- 避免程序员直接听命于项目经理
- *项目经理和程序员以功能规格说明书做为工作的基本依据*
- 项目经理要求实现的功能或所做的变更需要说服程序员


##编写功能规格说明书的准则

功能规格说明书最大的问题是:
> - 没有人读
> - 参考力不强
> - 不能做为实现功能有力的依据

1. 要幽默
   *引起足够的阅读的兴趣, 同样使别人更容易理解*

2. 像编写用大脑执行的代码一样写说明书
    - *内容应该便于理解， 而不是机械地描述*
    - *形象地描述更便于清晰地表达*
    - *必要的内容放进技术注解中, 并及时呈现*

3. 写得尽可能简单
    - "一图胜千言"
    - 避免单调的排版

4. 重读并修改几遍

5. 尽量不套用模板
    随着模板的积累, 会带有冗余内容, 变得不精简




#制定开发计划表
--------------

##一份开发计划表的sample

>| Feature | Task | Priority | Ori Est | Curr Est | Elapsed | Remain |
| :-----: | :--- | :------: | :-----: | :------: | :-----: | :----: |
| In-app | SDK compatibility test | 1 | 15 | 7 | 3 | 4 |
| In-app | dummy merchant app impl | 2 | 7 | 9 | 1 | 8 |
| In-app | spay handler | 2 | 10 | 12 | 0 | 12 |
| App2app | SDK compatibility test | 1 | 15 | 7 | 3 | 4 |
| App2app | dummy bank impl | 3 | 6 | 6 | 0 | 6 |


##制定开发计划表的原则

1. 使用MS Excel

2. 简单, 简洁
    2.1. 每人一张计划表
    2.2. *只体现任务和时间, 不做详细描述*

3. 继续为每个功能点划分子任务

4. 负责写代码的程序员本人为预估时间负责
    管理者预估的时间往往比实际使用时间少很多(3倍)

5. 适当细分任务, 保持合适的粒度
    5.1. 详细到点的预估能进一步review模块划分和流程
    5.2. **这样做使预估更加准确**
    5.3. 每个Task的时间应控制在2h~16h

6. 记录原始和当前的时间估计
    预估的时间对再次预估有参考价值, 也会锻炼预估时间的准确程度

7. 每天更新Elapsed一栏
    不需要时刻更新

8. 把休假, 节日等也加入计划表

9. 把调试时间也加入计划表

10. 把代码集成时间也加入计划表
    整合不同人员的代码会产生不可预料的问题

11. 把缓冲时间加入计划表
    琐碎时间占用时间比想像中的大

12. 拒绝开发经理压缩程序员预估的开发时间

13. 取舍问题

    - 预估时间往往小于实际开发时间
    - 会遇到延期交付/删减功能的抉择
    - 功能的取舍

    关于功能的取舍:

    13.1. 计划表的提供Task优先级/时间取舍的依据
    13.2. **拒绝将Task缩水而不是舍弃**
