More Joel on Software
===================

*(此文档中包含但不仅限于这本书的读后感, 也包括我个人发现的问题及理解 --tome.huang)*


[toc]


#[关于Joel文章的网站](http://www.joelonsoftware.com/)

#乔尔测试
---------


##乔尔测试内容包括

> 1. 你们使用版本控制系统吗?
> 2. 有一键部署吗?
> 3. 有每日构建吗?
> 4. 有Bug数据库吗?
> 5. 你们是否在写新代码前保证Bug都修复完了? ([无限缺陷方法论](#无限缺陷方法论))
> 6. 你们的进度表是最新的吗? ([我需要进一步读这个](#无痛软件时间表))
> 7. 有需求文档吗?
> 8. 程序员们有安静的工作环境吗?
> 9. 你们使用能买到的最好的工具吗?
> 10. 有测试团队吗?
> 11. 应聘者在面试时写代码吗?
> 12. 你们进行目标用户随机可用性测试吗([走廊可用性测试](#走廊可用性测试))?

[**我们是如何做的**](#我们是如何做的)


##无限缺陷方法论
>在Bug被修正之前等待的时间越长，以后要修正时的代价越大


##[无痛软件时间表](http://www.joelonsoftware.com/articles/fog0000000245.html)
(Painless Software Schedules)

##走廊可用性测试
在走廊随便拉一个人使用写好的程序, 重复进行可暴露大量问题


##我们是如何做的
1. 你们使用版本控制系统吗?
使用perforce, git做为版本管理工具

2. 有一键部署吗?
使用PBS, RBS平台, gradle, shell脚本控制版本同步, 编译和打包

3. 有每日构建吗?
不同项目构建周期不同, spay项目为一周两次

4. 有Bug数据库吗?
PLM系统, JIRA系统

5. 你们是否在写新代码前保证Bug都修复完了?
- bug修改与新工能开发同时进行.
- bug修改由QA及VOC驱动
- QA包括自测, SEL, CMT

6. 你们的进度表是最新的吗?
开发计划由developer给出建议, 由PM与BD协调后制定

7. 有需求文档吗?
需求文档，UX及GUI设计文档由PM提供

8. 程序员们有安静的工作环境吗?
没有, 会被不同的业务打断

9. 你们使用能买到的最好的工具吗?
是的, 性能足够的PC，多显示器, 市场版本开发样机, 正版软件

10. 有测试团队吗?
- spay项目组一般分配2-3名SEL测试人员做专题测试
- 项目release会分配2-3名SEL测试人员做版本测试
- 平均每developer配有0.13名测试人员

11. 应聘者在面试时写代码吗?
不写
参考: [The Guerrilla Guide to Interviewing <<面试简易指南>>](http://www.joelonsoftware.com/articles/fog0000000073.html)

12. 你们进行目标用户随机可用性测试吗?
spay项目是这样


##[这篇文章的原地址](http://www.joelonsoftware.com/articles/fog0000000043.html)




#语言选择和代码优化
-------------------

##施勒梅尔算法
~~Schlaemmer?~~

```c++
void strcat(char* dest, char* src) {
   while (*dest) dest++;
   while (*dest++ = *src++)
}
```

每次都是重头开始
**代码的效率**


##有关字符串的问题

###Pascal字符串
>- 字符串长度在255以内
>- 第一个字节存储字符串长度

e.g.
```c++
char* str = "\006hello!";
```


###String, StringBuffer和StringBuilder
1. String 内容不可变. 每次变更是生成了新的String. 大量String直接操作后会产生多个无用引用而
引起jvm开始gc, 速度会变慢.
2. StringBuffer**线程安全**, 维护缓冲区, 支持insert, append等操作, 对内容进行修改但不产生新对象.
3. StringBuilder**线程不安全**, 提供与StringBuffer兼容的API, 但不保证同步. 单个线程中比StringBuffer快




# 软件功能规格说明书
-------------------

## 它能带来的好处是
1. 编写代码的依据
- 功能定义先于编码, 能更加清晰地划分模块, 定义接口
- 更加清晰地讨论并形成解决方案

2. 减少沟通时间
 产品设计, 开发者, 测试人员及, 维护人员和客户都可能是读者

3. 制定开发进度的依据
 进度表对于开发过程同样重要

4. *细节问题会更早地暴露出来*


##功能规格说明书说应该包括

- 是功能说明书而不是技术说明书
- 从使用者的角度完整描述产品行为
- 设计产品最重要的是完成对用户体验的设计

*我目前对实现过程的理解:*
> 有哪些界面 -> 各界面功能 -> 界面间的跳转 -> work flow -> data flow -> 数据定义 -> 接口定义 -> 实现

应包含的内容:

0. 免责声明
    保护自己

1. 作者

2. 概述
    2.1. 文档的阅读人群
    2.2. 文档涉及的范围
    2.3. 文档不包含的内容

3. 使用场景
    构想真实生活中有**代表性**的人物的**逼真的**使用场景

    *可以包含:*
>    -他是谁
>    -他的职位/身份
>    -与产品有关场景的描述
>    -他如何使用产品
>    -产品如何帮他解决了问题
>    -解决问题后他变成了什么样子

4. 非目标
    4.1. 当前文档不做什么
    4.2. 当前文档设计中尚不支持的功能列表

5. 完整/全部业务流程图

6. *每个界面的规格说明*
    6.1. 为每个界面制定标准化命名
    6.2. *小节号可以代表界面间的关系*
    6.3. 界面中详细的功能和细节
    6.4. 界面中特别需要注意的内容
    6.5. **当前待解决的问题**
        6.5.1. 问题描述
        6.5.2. 当前进展
        6.5.3. 下一步需要做什么
    6.6. 必要的图表
    6.7. 必要的技术注解
    6.8. 显示说明对其它界面的跳转条件
    6.9. 界面的限制条件(用户输入限制, 软件/库/版本依赖, ..)

7. 不同角度的阅读者的注解

8. *修改记录*
spay项目和公司其它项目一般包含这个


##功能规格说明书说应及时更新

##这个文档应该由谁来编写?
**项目经理**
- 负责需求收集和软件功能设计, 然后编写此文档
- 协调与其它部门人员的合作(营销,文档,测试,本地化,其它)
- 了解公司的宏观战略

程序员
- 用代码实现以规格说明书的形式定义的功能

##项目经理的人选
1. 开发人员一般不适合做项目经理
开发人员的普遍弱项
- 文笔
- 市场嗅觉
- **用户视角**
- 界面设计

2. 营销人员一般不适合做项目经理
- 一般不具备技术素养

##项目经理与程序员的关系
- 避免程序员直接听命于项目经理
- *项目经理和程序员以功能规格说明书做为工作的基本依据*
- 项目经理要求实现的功能或所做的变更需要说服程序员


##编写功能规格说明书的准则

功能规格说明书最大的问题是:
> - 没有人读
> - 参考力不强
> - 不能做为实现功能有力的依据

1. 要幽默
   *引起足够的阅读的兴趣, 同样使别人更容易理解*

2. 像编写用大脑执行的代码一样写说明书
    - *内容应该便于理解， 而不是机械地描述*
    - *形象地描述更便于清晰地表达*
    - *必要的内容放进技术注解中, 并及时呈现*

3. 写得尽可能简单
    - "一图胜千言"
    - 避免单调的排版

4. 重读并修改几遍

5. 尽量不套用模板
    随着模板的积累, 会带有冗余内容, 变得不精简




#制定开发计划表
--------------

##一份开发计划表的sample

>| Feature | Task | Priority | Ori Est | Curr Est | Elapsed | Remain |
| :-----: | :--- | :------: | :-----: | :------: | :-----: | :----: |
| In-app | SDK compatibility test | 1 | 15 | 7 | 3 | 4 |
| In-app | dummy merchant app impl | 2 | 7 | 9 | 1 | 8 |
| In-app | spay handler | 2 | 10 | 12 | 0 | 12 |
| App2app | SDK compatibility test | 1 | 15 | 7 | 3 | 4 |
| App2app | dummy bank impl | 3 | 6 | 6 | 0 | 6 |


##制定开发计划表的原则

1. 使用MS Excel

2. 简单, 简洁
    2.1. 每人一张计划表
    2.2. *只体现任务和时间, 不做详细描述*

3. 继续为每个功能点划分子任务

4. 负责写代码的程序员本人为预估时间负责
    管理者预估的时间往往比实际使用时间少很多(3倍)

5. 适当细分任务, 保持合适的粒度
    5.1. 详细到点的预估能进一步review模块划分和流程
    5.2. **这样做使预估更加准确**
    5.3. 每个Task的时间应控制在2h~16h

6. 记录原始和当前的时间估计
    预估的时间对再次预估有参考价值, 也会锻炼预估时间的准确程度

7. 每天更新Elapsed一栏
    不需要时刻更新

8. 把休假, 节日等也加入计划表

9. 把调试时间也加入计划表

10. 把代码集成时间也加入计划表
    整合不同人员的代码会产生不可预料的问题

11. 把缓冲时间加入计划表
    琐碎时间占用时间比想像中的大

12. 拒绝开发经理压缩程序员预估的开发时间

13. 取舍问题

    - 预估时间往往小于实际开发时间
    - 会遇到延期交付/删减功能的抉择
    - 功能的取舍

    关于功能的取舍:

    13.1. 计划表的提供Task优先级/时间取舍的依据
    13.2. **拒绝将Task缩水而不是舍弃**





#每日构建
---------

##每日构建的标准
1. 自动构建
费时操作, 减少投入的精力

2. 每天一次
在固定时间进行

3. 完整构建
编译覆盖到所有的产物

4. *通知结果*
及时通知成功/失败及关键错误


##*它的好处*

1. 尽早发现编译问题
2. 有各时期的产物
3. 方便定位问题
4. 确定某问题在特定版本是否已经解决


##每日构建的tips
1. 构建过程实现自动化, 操作足够简单
    checkout -> build -> pack

2. 避免在每日构建的代码里直接修改问题
    这份代码只用于构建

3. 编译器警告等级调到最高

4. 解决构建失败的优先级最高

5. 构建失败信息发送给整个开发团队

6. 谁导致失败, 谁负责之后的构建

7. 建议午饭时间进行构建
    午饭回来后第一时间解决构建问题, 再继续下午的工作

8. 注意开发团队的时区问题
    不同时区合作的团队, 可在各自团队下班前1小时进行构建




#关于解决bug
------------

##计算解决bug的成本
- 当存在比解决bug更划算的工作时, 暂时放弃解决bug
- 从长远的角度看, 对于软件本身, 解决bug的收益很高
- 可以找到方法计算修复bug需要的代价和收益


##尽可能收集bug的所有信息
- 支持自动发送错误报告




#五类软件开发
------------

##哪五类
| 类别 | 用户人群 | 运行环境 | 开发难度 | 开发成本 | 软件质量 | 更新频率 |
| :--: | :-----: | :-----: | :-----: | :------: | :-----: | :------: |
| 盒装软件 | 广泛 | 多种多样 | 高 | 高 | 高 | 高 |
| 内部软件 | 很少 | 单一 | 相对低 | 相对低 | 相对低 | 很低 |
| 嵌入式软件 | 数量多 | 单一 | 一般 | 一般 | 高 | 非常低 |
| 游戏 | 数量多 | 多种多样 | 高 | 高 | 高 | 低 (通关后一般不再重玩) |
| 一次性代码 | 单一 | 单一 | 低 | 低 | 低 | 低 |


##不同开发类别有各自的方法论




#纸上原型设计
------------

##它的好处是
- 原型软件的成本和开发时间有可能比真正的开发还要高
- 纸上原型设计修改更加快速

##*我能想到的做法*
- 铅笔, 橡皮, A4
- 每张纸是一个界面/模块
- 为不同的纸制作索引标签

##相关信息
- 卡罗琳.斯奈德 <<纸上原型设计: 一种快速和轻松设计完善用户界面的方法>>




#软件架构的作用
--------------

- 软件架构研究的是解决问题的方式, 而无法解决"以前的技术做不到, 现在能做到"这样的问题
- 现今软件架构的作用被夸大(*这不一定是坏事*)
- **一个软件产品的成功, 是因为它解决了实际问题, 而不是因为使用了某种架构**




#计算机科学的三个错误观念
-----------------------

##搜索系统的难点在于找到足够多的结果
真正的难点是: 对结果进行排序 - *认清真正要解决的是什么问题*

##抗锯齿效果让文字看起来更舒服
它会让文字看起来更模糊 - *一种技术会让人想然地认为它能解决某种问题, 但实际效果不一定好*

##网络软件应该让网络资源的使用像本地资源一样
由于网络和本地资源访问速率不同, 网络情况不好时会出现'假死'情况 - *统一接口的代价: 掩盖了问题的真实原因; 出现冗余接口; 性能损耗*




#Windows和UNIX

| - | Windows | UNIX |
| :--: | :-----: | :-----: |
| 编程文化 | 编程对非程序员的价值 | 编程对其他程序员的价值 |
| 操作系统提供的功能 | 类似 |
| 程序运行结果 | 无论成功/失败, 提示用户 | 只有失败时提示用户 |
| 程序输出 | 各式各样 | 带有格式, 机器可读的文本 |
| 程序界面 | 方便使用者的图形化UI | 界面保持文本化 |
| 程序实现过程 | 图形界面 -> 核心调用 | 核心调用 -> 界面/输入接口 |
| API | 不开源 | 开源 |
| debug | 相对不方便 | 较方便 |